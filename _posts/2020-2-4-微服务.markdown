---
layout: post
title: 微服务
date: 2020-02-04 00:00:00 +0300
description:  # Add post description (optional)
img: # Add image post (optional)
tags: [架构, 微服务] # add tag
---

先放着大纲，趁宅在家，慢慢写

# 发布和引用服务

服务提供者如何发布一个服务，服务消费者如何引用这个服务。

最常见的服务发布和引用的方式有三种：

## RESTful API

可参考开源服务化框架[Motan](https://github.com/weibocom/motan)发布 RESTful API 的例子

## XML 配置

XML 配置这种方式的服务发布和引用主要分三个步骤：
- 服务提供者定义接口，并实现接口。
- 服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。
- 服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。

## IDL（interface definition language） 文件
通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流

** IDL 主要是用作跨语言平台的服务之间的调用 **

有两种最常用的 IDL：

- 一个是 Facebook 开源的 Thrift 协议，
- 另一个是 Google 开源的 gRPC 协议。

无论是 Thrift 协议还是 gRPC 协议，它们的工作原理都是类似的。以gRPC为例：

gRPC 协议使用 Protobuf 简称 proto 文件来定义接口名、调用参数以及返回值类型,
再通过protoc来生成不同语言平台的客户端及服务端代码，从而具备**跨语言**服务调用能力。

文件helloword.proto，定义了一个接口方法SayHello,请求参数HelloRequest,返回值HelloReply：

```
// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}

}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}  
```

服务端代码：
```java

private class GreeterImpl extends GreeterGrpc.GreeterImplBase {

  @Override
  public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();
    responseObserver.onNext(reply);
    responseObserver.onCompleted();
  }

  @Override
  public void sayHelloAgain(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello again " + req.getName()).build();
    responseObserver.onNext(reply);
    responseObserver.onCompleted();
  }
}
```

客户端代码：
```java
public void greet(String name) {
  logger.info("Will try to greet " + name + " ...");
  HelloRequest request = HelloRequest.newBuilder().setName(name).build();
  HelloReply response;
  try {
    response = blockingStub.sayHello(request);
  } catch (StatusRuntimeException e) {
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }
  logger.info("Greeting: " + response.getMessage());
  try {
    response = blockingStub.sayHelloAgain(request);
  } catch (StatusRuntimeException e) {
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }
  logger.info("Greeting: " + response.getMessage());
}  
```

| 服务方式 | 使用场景 | 缺点 |
| -----| ---- | ---- |
| RESTful API | 跨语言平台,组织内外皆可用，松耦合 | 使用HTTP作为通讯协议，相比TCP协议，性能较差 |
| XML配置 | java平台，一般用作组织内部 | 不支持跨语言平台 |
| IDL文件 | 跨语言平台,组织内外皆可用，性能佳 | 有一定的耦合性 |

# 注册和发现服务

服务提供者（RPC Server）、服务消费者（RPC Client）和服务注册中心（Registry）

- RPC Server 提供服务，在启动时，根据服务发布文件 server.xml 中的配置的信息，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。

- RPC Client 调用服务，在启动时，根据服务引用文件 client.xml 中配置的信息，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。

- 当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地内存中缓存的服务节点列表。
RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。

## 注册中心实现方式

主要涉及几个问题：
1. 注册中心需要提供哪些接口，该如何部署；
2. 如何存储服务信息；
3. 如何监控服务提供者节点的存活；
4. 如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。

### 1.注册中心 API

注册中心必须提供以下最基本的 API，例如：
- 服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。
- 服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。
- 心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。
- 服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。
- 服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。

除此之外，为了便于管理，注册中心还必须提供一些后台管理的 API，例如：
- 服务查询接口：查询注册中心当前注册了哪些服务信息。
- 服务修改接口：修改注册中心中某一服务的信息。

## Eureka ZooKeeper

CP :Zookeeper当master挂了，会在30-120s进行leader选举，这点类似于redis的哨兵机制，在选举期间Zookeeper是不可用的，这么长时间不能进行服务注册，是无法忍受的，别说30s，5s都不能忍受。
这时Zookeeper集群会瘫痪，为了保持节点的一致性，牺牲了A/高可用。

AP :即使Eureka有部分挂掉，还有其他节点可以使用的，他们保持平级的关系，但信息有可能不一致。


# RPC远程服务调用

# 监控微服务调用

# 追踪微服务调用

# 服务治理

## Consul

Consul是一个服务网格（微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控）解决方案，
它是一个一个分布式的，高度可用的系统，而且开发使用都很简便。
它提供了一个功能齐全的控制平面，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心。


# 容器化

# 微服务实现DevOps