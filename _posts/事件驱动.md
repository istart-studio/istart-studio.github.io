


## 2.8 事件代理与消息代理


事件代理是围绕提供有序的事实日志而设计的。

消息代理只提供消息的队列，消息的消费是基于每个队列进行处理的。
事件代理维护着一个单独的记录总账，并通过索引管理每个单独的访问，因此每个单独的消费者能够访问所有必需的事件。

消费后删除事件使得消息代理不足以向所有应用程序提供无限期存储、全局可访问、可重放和单一的事实来源。

事件代理支持一个不可变的追加日志，以保留事件顺序的状态。消费者可以在任何时候从日志中的任何位置提取数据并进行重新处理。此模式对于启用事件驱动型微服务是必不可少的，但消息代理无法提供。

消息队列提供了有用的访问模式，但在使用严格分区的事件流时可能难以实现。

# 3 通信和数据契约

    信息论之父 Claude Shannon 指出，通信的最大障碍是，确保信息的消费者能够准确地再现生产者的信息，从而使信息的内容和含义都得到正确的传达。

在事件驱动生态系统中，事件就是消息，且是通信的基本单元。
一个事件应该尽可能准确地描述发生了**什么（What）**以及**为什么（Why)**会发生。这是事实的一个状态，当把系统中的所有其他事件结合在一起时，就能提供事实发生的完整历史。


## 3.1 事件驱动数据契约

要传递的数据的格式和创建数据的逻辑构成了**数据契约**。它赋予了事件意义和形式，使其超出产生事件的上下文，并将数据的可用性扩展到消费者应用程序.

组成部分：
 - 第一部分是数据定义，或者说是会产生什么（例如，字段、类型和各种数据结构）。
 - 第二部分是触发逻辑，或者说是为什么会产生（例如，触发事件创建的特定业务逻辑）。随着业务需求的发展，可以对数据定义和触发逻辑进行更改。

### 3.1.1 使用显式schema作为契约

生产者在使用隐式 schema 时，生产者也可能不会注意到（或者他们的单元测试没有发现）他们已经更改了事件数据定义。

    部落知识（tribal knowledge）是指仅被公司里的一部分人（而非所有人）了解的信息。这种信息没有任何书面记录。

schema 定义中对注释和元数据的支持对于传递事件的含义至关重要。围绕事件的生产和消费的知识应该
尽可能接近事件定义。schema 注释有助于消除对数据含义的模糊性，并减少消费者误解的机会。注释主
要在以下两方面特别有价值。
指定事件的触发逻辑。这通常写在 schema 文件的首部，并且应该清楚地说明生成事件的原因。
给出结构化 schema 中特定字段的上下文和清晰解释。例如，日期时间字段的注释可以说明格式是 UTC、ISO 还是 Unix 时间。

### 3.1.3 全能的schema演化


微服务的核心价值主张是，**除非在特殊情况下，否则它们应该独立于其他服务的发布周期**。


一组显式的 schema 演化规则可以让消费者和生产者按照自己的时间安排更新应用程序。这些规则称为兼容性类型。

- 向前兼容性

允许像读取旧 schema 生成的数据一样读取新 schema 生成的数据。在事件驱动架构中，这是一个特
别有用的演化需求，因为最常见的系统变更模式是从生产者用新的 schema 更新其数据定义并生成数据开
始的。消费者只需要在访问新字段时更新其 schema 副本和代码。

- 向后兼容性

允许像读取新 schema 生成的数据一样读取旧 schema 生成的数据。这使得数据消费者可以用新的 schema 读取旧的数据。向后兼容性对于以下场景来说特别有用。

消费者正在等待上游团队发布新特性。如果新的 schema 已被定义，那么消费者就可以在生产者发布 之前发布自己的更新。

schema 编码的数据来自部署在硬件设备上的产品应用，比如手机应用程序会上报用户指标。可以对新版本产品的 schema 格式做出更新，同时保持对之前版本的兼容性。
消费者应用程序可能需要重新处理事件流中的数据，而这些数据是用旧的 schema 版本生成的。
schema 演化确保了消费者可以将旧的版本转换成现在使用的版本。如果没有向后兼容性，那么消费
者将只能读取最新格式的消息。

- 完全兼容性

将向前兼容性和向后兼容性结合起来，这是最强的保证，并且应该尽可能地使用这种方式。你可以在将来随时放宽兼容性要求，但收紧它们往往要困难得多。


### 3.3.4 保持事件的单一用途

一种常见的反模式是向事件定义中添加 type 字段，其中不同的 type 值表示事件的特定子功能。这通常是针对“相似但不同”的数据执行的操作，常常是由于实现者错误地将事件标识为单一用途而造成的结果。

    需要特别注意的是，添加 type 字段并不能降低或消除所生成数据中固有的底层复杂性。事实
    上，这种复杂性只不过从具有不同 schema 的多个不同事件流转移到了将所有 schema 合并到一个事
    件流中的联合体。可以说，这实际上增加了复杂性。schema 的未来演化变得更加困难，维护产生事
    件的代码也变得更加困难。

记住数据契约定义的原则。事件应该与单个业务操作相关，而不是记录大量数据的通用事件。如果你发觉
自己需要一个具有各种 type 参数的泛型事件，那么这通常是一个信号，表明你没有很好地定义问题空间
和界限上下文。

花点儿时间考虑 schema 是如何演变的。确定所生成数据的主要业务用途、范围、域，以及是否正将其构
建为单一用途。验证 schema 是否准确地反映了业务关注点，特别是对于覆盖广泛业务功能职责范围的系
统。业务范围和技术实现有可能是不一致的。最后，不断发展的业务需求会要求你重新审视事件定义并可
能更改它们，而不仅仅是对单个 schema 的增量定义。如果发生了足够多的业务变更，则可能需要对事件
进行拆分和重新定义。

### 3.3.5 最小化事件

当你看到一个产生非常大的事件的设计时，有几点注意事项。确保数据与事件直接相关。有些数据可能只
是“以防万一”地被添加到事件中，但对下游消费者没有任何实际用处。如果发现所有的事件数据确实是
直接相关的，那么退一步看看你的问题空间。你的微服务是否需要访问这些数据？你可能需要评估界限上
下文，以查看服务是否正在执行合理数量的工作。也许可以通过将附加功能拆分为单独的服务来缩小服务
范围。

但是这种情况并不总是可以避免的，有些事件处理器会生成非常大的输出文件（可能是一个大图像），这
些文件太大了，以至于无法放入事件流的单条消息中。在这些场景中，可以使用指向实际数据的指针，但
要谨慎。这种方法以多个事实来源和内容可变的形式增加了风险，因为不可变的日志无法保证能保存这个
系统之外的数据。

### 3.3.6 让潜在的消费者参与事件设计

在设计新事件时，让这些数据的所有潜在消费者都参与进来是很重要的。与生产者相比，消费者将更好地
理解自己的需求和预期的业务功能，并可能有助于澄清需求。消费者也将更好地了解即将到来的数据。一
次联席会议或讨论可以解决两个系统之间有关数据契约的任何问题。


### 3.3.7 避免将事件作为信号量或信号

系统输出一个事件，表明某一作业的工作已经完成。虽然事件本身表明工作已
完成，但实际的工作结果不包括在事件中。这意味着要正确消费此事件，必须找到已完成工作的实际位
置。一旦一段数据有两个事实来源，就会出现一致性问题。

## 3.4 小结

- 异步的事件驱动架构严重依赖于事件质量。
- 高质量的事件用可演化的 schema 显式定义、具有定义良好的
触发逻辑，并包括带有注释和文档的完整 schema 定义。
- 显式 schema 是广泛采用事件驱动架构的一个重要组成部分，特别是随着组织的发展，部落知
  识在组织范围内的传播已变得不可能。
- 事件定义应该是狭义的，并密切聚焦于事件的领域。
- 事件应该表示一个特定的业务情况，并包含适当的数
  据字段来记录所发生的事情。
- schema 演化是显式 schema 的一个非常重要的方面，因为它允许事件域模型有一个受控的变更机制。
- schema 演
  化允许生产者和消费者将自己与对其操作不重要的更改隔离开来，同时允许那些关心更改的服务相应地更
  新自己。
- 在某些情况下，schema 演化是不可能的，破坏性的变更一定会发生。生产者和消费者干系人必须沟通这
  些变化背后的原因，并一起重新定义未来的领域模型。
- 迁移旧事件可能是必要的，也可能没必要。

# 4 将事件驱动架构与现有系统集成

## 4.1 什么是数据解放

